<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hopsken</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hopsken.com/"/>
  <updated>2018-03-22T02:42:11.199Z</updated>
  <id>http://hopsken.com/</id>
  
  <author>
    <name>Hopsken</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 单位与百分比值详述</title>
    <link href="http://hopsken.com/2018/03/18/CSS-unit/"/>
    <id>http://hopsken.com/2018/03/18/CSS-unit/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-03-22T02:42:11.199Z</updated>
    
    <content type="html"><![CDATA[<p>单位是我们控制尺寸的重要工具，也是我们在编写 CSS 代码时会经常使用到的。CSS 的单位主要分成两种：绝对单位和相对单位。<a id="more"></a></p>
<h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>CSS 中的绝对单位包括：mm（毫米），cm（厘米），in（英寸），pt（点），pc（派卡）。</p>
<ul>
<li>mm，cm，in 这三个都很好理解，就是我们拿着尺子对着屏幕量出来的真实宽度。不过说起来，现在全世界貌似只有美帝还在使用英寸作为长度单位，从侧面也可以看出美帝的影响力。（1英寸=2.54厘米）</li>
<li>pt 和 pc 这两个倒是不怎么常见。其中，pt（点）其实是一种标准印刷度量单位，长度上1英寸=72点。pc（派卡）也是印刷术语，1派卡=12点=1/6英寸。</li>
</ul>
<p>事实上，我们很少需要用到绝对单位。因为一般来说我们网页需要在各种不同大小的屏幕上显示，使用绝对长度很难确保内容显示的一致性。</p>
<h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>CSS 中的相对长度单位包括：px（像素），em，ex，ch，rem，vw，vh，vmin，vmax</p>
<ul>
<li>px（像素），像素就是显示器上的一个点。关于 px 是相对长度单位还是绝对长度单位这一点有争议，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Values_and_units" target="_blank" rel="external">MDN</a>把 px 归为绝对单位，而《CSS权威指南（第三版）》中则把它归为相对单位（因为取决于显示设备的分辨率）。</li>
<li>em，ex，ch。1em 被定义为一种给定字体的 font-size 值。比方说一个元素的 font-size 为 20px，那么对于这个元素，1em=20px。另外如果没有为当前元素指定 font-size，但是因为font-size值是会继承的，所以会取父元素的值。举个栗子：</li>
</ul>
<pre><code class="html">&lt;div&gt;
    &lt;p&gt;Lorem ipsum &lt;span&gt;foo bar&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

div {font-size: 20px;}
p {font-size: 1.2em;} //计算值为 20px*1.2 = 24px
span {font-size: 0.8em;} //计算值为 20px*1.2*0.8=19.2px
</code></pre>
<ul>
<li>ex，ch。理论上，ex 是指所用字体中小写 x 的高度，ch 是指所用字体 0 的宽度，但是浏览器对两个单位的支持有限，很多浏览器的实际做法是取1ex=0.5em。</li>
<li>rem，即 root em，是 CSS 3中新定义的单位。与 em 类似，不过 rem 永远是以默认基础字体大小为参照的，继承的字体大小不会影响它。我们可以基于rem这一特性构建出响应式布局。一般浏览器默认的字体大小都是16px。</li>
<li>vw，vh，即 viewport width 和 viewport height，也是 CSS 3 中新添加的单位。1vw = 1/100 视口宽度（viewport width），1vh = 1/100视口高度（viewport height）。</li>
<li>vmin，vmax，这两个也是 CSS 3 新定义的视口单位。其中，vmin 取 vw 与 vh 中较小的那个单位，vmax 则相反取较大的那个。</li>
</ul>
<h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>百分比值是 CSS 中非常常用的一种数值，也是很多新手很容易困惑的地方。形式上百分比值就是实数+百分号（%）。因为百分比值几乎总是相对于另一个值的，而对于不同的属性，选择的参考值也是不同的，所以得到的计算值也会不同。</p>
<p>要想真正掌握百分比值的计算，首先要了解<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/All_About_The_Containing_Block" target="_blank" rel="external">包含块（MDN）</a>的概念。大多数情况下，包含块就是父级块元素的 content 区域，即内容区。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参照值</th>
<th style="text-align:left">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">包含块宽度</td>
<td style="text-align:left">[max/min-]width、left、right、text-indent、padding-*、margin-* 等</td>
</tr>
<tr>
<td style="text-align:left">包含块高度</td>
<td style="text-align:left">[max/min-]height、top、bottom 等</td>
</tr>
<tr>
<td style="text-align:left">继承字号</td>
<td style="text-align:left">font-size 等</td>
</tr>
<tr>
<td style="text-align:left">自身字号</td>
<td style="text-align:left">line-height 等</td>
</tr>
<tr>
<td style="text-align:left">自身行高</td>
<td style="text-align:left">vertical-align 等</td>
</tr>
<tr>
<td style="text-align:left">自身宽高</td>
<td style="text-align:left">border-*-*-radius 等</td>
</tr>
<tr>
<td style="text-align:left">边界框尺寸</td>
<td style="text-align:left">transform: translate() 等</td>
</tr>
<tr>
<td style="text-align:left">特殊情况</td>
<td style="text-align:left">background-position: 相对于背景区域尺寸减去背景图尺寸</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位是我们控制尺寸的重要工具，也是我们在编写 CSS 代码时会经常使用到的。CSS 的单位主要分成两种：绝对单位和相对单位。
    
    </summary>
    
      <category term="前端" scheme="http://hopsken.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://hopsken.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（JavaScript 描述）</title>
    <link href="http://hopsken.com/2017/08/20/javascript-data-stuctures/"/>
    <id>http://hopsken.com/2017/08/20/javascript-data-stuctures/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-21T09:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>数组<ol>
<li>常用方法</li>
<li>二维数组</li>
</ol>
</li>
<li>列表</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>字典</li>
<li>散列</li>
<li>集合</li>
</ol>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义是：一个存储元素的线性集合，元素可以通过索引任意存取。索引通常是数字。然而在 JavaScript 中，数组是一种特殊的对象，索引为该对象的属性，而 JavaScript 中对象的属性名必须是字符串类型。看上去很奇怪，不过也正因此，数组可以作为其他数据结构的基础。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>创建数组的方法有很多，不过一般推荐使用 [] 操作符。</p>
<pre><code class="javascript">var nums = []

nums.unshift(num)   //在开头添加元素
nums.shift(num)     //删除开头元素
nums.pop()          //删除末尾元素
nums.push(num)      //在末尾添加元素
nums.splice(start, n, elements)     //在中间 `start` 位置删除 n 个元素，并添加若干个 elements。
nums.reverse()      //反序
nums.sort()         //将数字从小到大排序
</code></pre>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>按照《JavaScript 精髓》一书中的做法，通过扩展 JavaScript 数组对象实现。</p>
<pre><code class="javascript">Array.matrix = function(numrows, numcols, initial) {
    var arr = []
    for (var i = 0; i &lt; numrows; ++i) {
        var columns = []
        for (var j = 0; j &lt; numcols; ++j) {
            columns[j] = initial
        }
        arr[i] = columns
    }
    return arr
}
</code></pre>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是一组有序的数据，适合用于保存的数据不太多时。</p>
<p>列表的抽象数据类型定义：</p>
<pre><code>listSize pos length 
insert() append() remove() clear()
front() end() currPos() moveTo()
prev() next() hasPrev() hasNext() 
toString() getElement() contains()
</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问。遵循<em>后入先出</em>的数据结构。因此，只能访问栈顶的元素，即最后加入的元素。</p>
<pre><code>push()  //向栈内压入元素
pop()   //删除栈顶元素
peek()  //返回栈顶元素而不删除它
</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种列表，不同的是队列遵循<em>先进先出</em>的数据结构，即只能在队尾插入元素，在队首删除元素。</p>
<pre><code>enqueue()   //向队尾插入元素，即 push()
dequeue()   //删除队首元素，即 shift()
front()     //返回队首元素
back()      //返回队尾元素
</code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>与列表的是，链表的底层数据结构不是数组，而是节点。与数组相比，链表的性能更加优越。缺陷是不方便进行随机访问。数组元素通过位置来进行引用，而链表元素则通过相互关系来引用。每一个节点都包含元素数据和指向下个节点的链接。</p>
<pre><code class="javascript">// Node 类
function Node() {
    this.element = element
    this.next = null
}
// 链表类
function LinkedList() {
    this.head = new Node(&quot;head&quot;)    //初始化头节点
    this.find = find        //查找
    this.insert = insert    //插入节点
    this.remove = remove    //移除节点
    this.display = display  //显示
}
</code></pre>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fiqmm75lt4j30e806mq2r.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fiqmm6s1thj30hl058a9v.jpg" alt=""></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了能够方便的从后往前遍历，为每个节点添加指向前驱的链接。</p>
<pre><code class="javascript">// Node 类
function Node() {
    this.element = element
    this.next = null
    this.previous = null
}
</code></pre>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>与单向列表相似，唯一的区别在于初始化链表时，头节点的 next 属性指向它本身。这种行为会传导下去，这样，链表的尾节点就会指向头节点。</p>
<pre><code class="javascript">function LinkedList() {
    this.head = new Node(&quot;head&quot;)    //初始化头节点
    head.next = head    // 头节点 next 属性指向自身
    //...
}
</code></pre>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典通过<em>键-值对</em>来存储数据。可以利用 JavaScript Object 类本身的特性来实现 Dictionary 类。使用 () 操作符来引用，而不是 []。</p>
<pre><code class="javascript">function Dictionary() {
    this.datastore = []
    this.add = add  // add(key, value)，即 this.datastore[key] = value
    this.find = find
    this.remove = remove
    this.showAll = showAll
    this.count = count
    this.clear = clear
}
</code></pre>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>散列是一种可以快速插入或取用的数据存储技术。散列使用的数据结构称为<em>散列表</em>。使用散列表存储时，通过有个<em>散列函数</em>讲键映射为一个数字，数字范围是 0 到散列表的长度。散列表的长度是预先定义的，一般取质数。当两个值映射到同一个值时则会发生<em>碰撞</em>。</p>
<h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>除留余数法：最简单的方法。以数组的长度对键取余（当键值为字符串时取其 ASCII 码之和），为了尽量避免结果相等发生碰撞，所以数组长度一般取质数。</p>
<p>霍纳算法：除留余数法很容易会发生碰撞。而霍纳算法则可以更好地避免这个问题。霍纳算法仍然计算字符串中各个字符的 ASCII 码值，不过在求和时每次都要乘一个质数，一般建议使用一个较小的质数。</p>
<pre><code class="javascript">function HornerHash(string, arr) {
    const H = 31
    var total = 0
    for (var i=0; i&lt;string.length; ++i) {
        total += H*total + string.charCodeAt(i)
    }
    total = total % arr.length
    return parseInt(total)
}
</code></pre>
<h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>开链法：在实现散列表的底层数组时，每个数组元素又是一个新的数据结构，这样就可以存储多个键了，当两个键散列后的数值相同时，依然可以保存在相同的位置。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fircfylz5bj30c407h743.jpg" alt="开链法"></p>
<p>线性探测法：线性探测法属于一种更一般的散列技术：<em>开放寻址散列</em>。当发生碰撞时，线性探测法会检查散列表中下一个位置是否为空，如果为空，则填入数据，否则，继续检查下一个位置，知道找到空位并填入。</p>
<p>一般来说，如果数组的大小是到存储数据个数的1.5倍，则使用开链法。如果数组大小为待存储数据的两倍及以上，则使用线性探测法。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一种包含不同元素的数据结构。集合具有两个特性。首先，集合元素是无序的，其次，集合中不允许相同成员存在。</p>
<p>集合的几个基本操作：并集、交集、补集、子集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="http://hopsken.com/tags/Note/"/>
    
      <category term="JavaScript" scheme="http://hopsken.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择器</title>
    <link href="http://hopsken.com/2017/06/04/CSS-selector/"/>
    <id>http://hopsken.com/2017/06/04/CSS-selector/</id>
    <published>2017-06-03T16:00:00.000Z</published>
    <updated>2017-08-14T04:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一个练习 CSS 选择器的小游戏 <a href="https://flukeout.github.io/" target="_blank" rel="external">CSS Diner</a>。<br><a id="more"></a></p>
<ol>
<li><p>标签选择器</p>
<pre><code>h2 { }
</code></pre></li>
<li><p>类选择器</p>
<pre><code>.className { }
</code></pre></li>
<li><p>ID 选择器</p>
<pre><code>#id { }
</code></pre></li>
<li><p>属性选择器</p>
<ol>
<li>简单属性匹配<pre><code>a[href] { }
</code></pre></li>
<li>根据具体属性值<pre><code>a[href=&quot;google.com&quot;] { }
</code></pre></li>
<li>根据部分属性值<pre><code>a[href~=&quot;google.com&quot;] { }
</code></pre>其他一些匹配模式:<pre><code class="css">p[foo^=&quot;bar&quot;] /*匹配开头*/ 
p[foo$=&quot;bar&quot;] /*匹配结尾*/
p[foo*=&quot;bar&quot;] /*包含*/
</code></pre>
</li>
</ol>
</li>
<li><p>后代（上下文）选择器</p>
<ol>
<li>选择后代元素</li>
<li><p>选择子元素 </p>
<pre><code> h1 &gt; strong { }
</code></pre></li>
<li><p>选择兄弟元素 </p>
<pre><code> h1 + p { } /* 选择紧接在一个 h1 元素后出现的所以段落，h1 与 p 有相同的父元素 */
</code></pre></li>
</ol>
</li>
</ol>
<ol>
<li><p>伪类选择器和伪元素选择器</p>
<ol>
<li><p>伪类选择器 </p>
<pre><code> a:visited {color: red;}
</code></pre><ul>
<li>静态伪类<br><code>:link  :visited :first-child</code><br>   <code>:first-child</code>伪类：用于选择作为某个未知元素的第一个子元素的指定元素。<br>  <code>:lang(fr)</code>伪类：根据元素的语言来选择。不同于 <code>|=</code>属性选择器，<code>lang</code>的语言信息由属性与 META 信息提供，甚至可能包括 HTTP 头信息。</li>
<li><p>动态伪类<br><code>:focus :hover :active</code></p>
<p>结合伪类<br>推荐顺序：<code>link-visited-focus-hover-active</code></p>
</li>
</ul>
</li>
<li><p>伪元素选择器</p>
<ul>
<li><p>设置首字母样式</p>
<pre><code>p:first-letter {font-size: 200%}
</code></pre></li>
<li><p>设置首行样式</p>
<pre><code>p:first-line { }
</code></pre><p><em>需要注意的是，应用<code>:first-letter :first-line</code>的元素允许的属性是有限制的。</em></p>
</li>
<li>设置之前和之后元素的样式<pre><code>h2:before {content:&quot; &quot;}
h2:after { }
</code></pre></li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一个练习 CSS 选择器的小游戏 &lt;a href=&quot;https://flukeout.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Diner&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hopsken.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的 Chrome 插件</title>
    <link href="http://hopsken.com/2016/11/21/my-chrome-extensions/"/>
    <id>http://hopsken.com/2016/11/21/my-chrome-extensions/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-03-19T05:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>1Password<br> 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～</p>
</li>
<li><p>Adblock Plus<br> 大名鼎鼎的ABP！广告？那是什么？</p>
</li>
<li><p>Instapaper<br> Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。<a id="more"></a></p>
</li>
<li><p>Isometric Contributions<br> 让你的 Github 贡献看起来更美观～<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03fyxrccj30hs0b4wfi.jpg" alt="" title="Isometric Contributions"></p>
</li>
<li><p>JSON Formatter<br> 更美观的 JSON 输出，调试 API 的时候很方便。<br> <img src="http://ww2.sinaimg.cn/large/006tNc79gw1fa03l92tu2j30hs0b4wg3.jpg" alt="" title="JSON Formatter"></p>
</li>
<li><p>Octotree<br> 像浏览本地文件夹一样浏览 Github Repo<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03muhx87j31e00wrtgp.jpg" alt="" title="Octotree"></p>
</li>
<li><p>RatherNice<br> 一个可以让你心情好起来的新标签页插件～<br> <img src="https://ww2.sinaimg.cn/large/006tKfTcly1fds2aqps4sj30zk0m8ta6.jpg" alt="" title="RatherNice"></p>
</li>
<li><p>Stylebot<br> 可以任意修改网站的 CSS 来让网站看起来更舒服，也可以用来屏蔽广告。你还可以使用别人分享的 CSS 风格，当然你也可以自己设计并分享给其他人。</p>
</li>
<li><p>v2ex plus<br> v2ex的插件。对于一个经常逛V站的人来说几乎必备。</p>
</li>
<li><p>Vimium<br>如果你是 Vim 党，你一定会喜欢这个插件的！你可以像在 Vim 里一样，使用快捷键来控制网页滚动、跳转、搜索等等，极大提高工作效率。</p>
</li>
<li><p>Wappalyzer<br>用来分析网站的架构。前端工程师必备。</p>
</li>
<li><p>印象笔记·剪藏<br>把当前网页内容收藏到印象笔记里面，填充自己的资料库。</p>
</li>
<li><p>印象笔记·悦读<br>印象笔记的另一款插件。提供更舒服的阅读体验。</p>
</li>
<li><p>高效网页截图编辑插件<br>一款强大的网页截图工具。开发者也很有趣。</p>
</li>
<li><p>AdF.ly Skipper<br>跳过AdF.ly的一个工具。之前玩 Minecraft 下载mod的时候经常会用到。</p>
</li>
</ol>
<p>最后，安利一款 chrome 主题：<a href="https://chrome.google.com/webstore/detail/slinky-brushed/piiokbhpgldooopjdacdondngonfljoc?hl=zh-CN" target="_blank" rel="external"> Slinky </a>，换来换去最喜欢的还是这个！</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;1Password&lt;br&gt; 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adblock Plus&lt;br&gt; 大名鼎鼎的ABP！广告？那是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instapaper&lt;br&gt; Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。
    
    </summary>
    
    
      <category term="Chrome" scheme="http://hopsken.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>记第一次十公里跑</title>
    <link href="http://hopsken.com/2016/03/27/1000m-running/"/>
    <id>http://hopsken.com/2016/03/27/1000m-running/</id>
    <published>2016-03-26T16:00:00.000Z</published>
    <updated>2016-10-04T10:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。<br>    <a id="more"></a><br>　　我是从新年过后才开始跑步的，到现在为止差不多一个多月了。差不多每周跑四次，每次至少五公里。截止目前，累计距离72.44公里，跑步记录14次。所以，我目前最多只能算是一个初级跑者。现在的目标是半年内完成一次半程马拉松，大学四年内至少完成三次全程马拉松。说起我跑步的原因，首先是为了减肥（我想这也是多数跑者开始跑步的原因吧）再者，是因为读了村上春树的《当我谈跑步时我谈些什么》，颇受触动，为其精神所感染。后来，不知从第几次跑步开始，我开始喜欢上了这项运动。我喜欢上了两公里时候脚酸的要死的感觉，喜欢上了四公里时腿重得像灌了铅的感觉，喜欢上了耳机里“您已经跑了五公里”的提示音，喜欢了五公里后多跑的每一百米。总之，不管愿不愿意，我已经爱上了跑步。</p>
<h3 id="10KM准备"><a href="#10KM准备" class="headerlink" title="10KM准备　"></a>10KM准备　</h3><p>　　在跑过十次五公里之后，我决定挑战一下10KM跑。时间是周日上午，地点是学校网球场旁的跑道。<br>　　<br>　　在经过了两天的休整之后，周日如期而至。九点起床，舍友还在酣睡之中；洗漱，特地把脸洗了两遍；吃早饭，还是以前吃的那些；顺道去食堂旁的小商店买了一瓶矿泉水以及一袋彩虹糖。认真地翻看网上找到的跑前拉伸动作。毕竟是第一次跑十公里，不能像以前跑五公里的时候那样只在跑完后做一下简单拉伸，不能太随意。<br>　　<br>　　终于来到了操场。因为是周日，操场没什么人。只有几个家长在带着孩子打网球，还有路过的去操场旁边的成人教育楼上课的人们。在做了十分钟的准备活动之后，就正式开始了我的十公里征程啦！<br>　　<br>　　因为不是标准化田径场，绕操场一圈的距离没具体测过，大概是300米吧。那么10KM就是要绕着跑三四十圈了。额，听起来有点吓人啊。不过，反正咱是慢跑，而且既然之前跑五公里跑完之后也不是很累，所以应该没什么问题吧。只要能保持6‘30’‘的配速，应该没什么问题的。</p>
<h3 id="以下内容纯属意识流"><a href="#以下内容纯属意识流" class="headerlink" title="以下内容纯属意识流"></a>以下内容纯属意识流</h3><p>　　“您已经跑了一公里，用时6’14‘’，剩余距离9公里”<br>　　“啊，已经跑了一公里了啊。今天有点冷啊。。再多跑几步应该就会暖和起来了吧。”<br>　　<br>　　“您已经跑了两公里，用时6‘38‘’，剩余距离8公里”<br>　　“已经跑了五分之一了啊！加油加油！哎，那边那个打网球的技术好烂啊。”<br>　　<br>　　“您已经跑了三公里，用时6‘28‘’，剩余距离7公里”<br>　　“哎呀，已经三公里了哎，差不多三分之一。奇怪，按理说这个时候腿已经开始酸了，今天怎么没有，难道是因为今天跑之前做足了拉伸。也许吧。看来今天状态不错嘛，跑个十公里应该没问题。哈哈哈”<br>　　<br>　　“您已经跑了四公里，用时6‘28’‘，剩余距离6公里”<br>　　“哟嚯，又是6’28‘’，记得上一公里也是花了这么长时间，看来速度控制的不错嘛。嗯，腿和脚都没有酸痛的感觉，nice！啊呀，这里有一坨‘犬之翔’哎。woc，还好没踩到。还好我机智，哈哈哈。”<br>　　<br>　　“您已经跑了五公里，用时6‘30’‘，剩余距离5公里”<br>　　“已经跑了五公里了啊，一半了哎，平时这个时候都可以停下来了。 嗯，目前看来，耐力和体力都没什么问题。加油吧！噫，这坨翔怎么还在这里。”<br>　　<br>　　“您已经跑了六公里，用时6’42‘’，剩余距离4公里”<br>　　“六公里了哈。woc，竟然有个妹子在男生宿舍门口，手里还拎了个星巴克的咖啡。好烦，可恶的情侣= =算了，我还是跑自己的步，懒得理你们。Hello，翔，你还在啊。”<br>　　<br>　　“您已经跑了七公里，用时6‘24’‘，剩余距离3公里”<br>　　“哎呀，我去，怎么还有三公里……一不小心就跑了45分钟了，我实在是太棒了！哈哈哈！呦，又有家长带着小孩来玩。哟嚯，不错啊，大叔，这么大啤酒肚玩的了单杠，给你竖个大拇指。额，还是不竖了吧，人家会觉得我是傻X吧。。”<br>　　<br>　　“您已经跑了八公里，用时6’34‘’，剩余距离2公里”<br>　　“八公里，还有两公里，哎呀，好烦啊，怎么还有两公里，妈呀，我不想跑了啊，老这么跑好无聊啊。前面那个跑超过我的那个女生，真是太不上路子了，哥这是在跑十公里好吗？十公里ok？我跑了这么久，你才跑一会儿，你怎么好意思跑超过我呢？你这样让我很难堪好吗？那啥，前面的那两个熊孩子让一让，挡住我的路了。算了，还是我让过去吧。。。woc，怎么这坨翔还在这里。”<br>　　<br>　　“您已经跑了九公里，用时6‘36’‘，剩余距离1公里，加油！”<br>　　“还有最后一公里啊，坚持下来都可以了！哎呀，一不小心就跑了将近一个小时了啊。哥实在是太厉害了！等会回去一定要把这次跑步写下来！嗯，等马上跑完，我要好好秀一秀😏”<br>　　<br>　　“您已经跑了十公里，用时6’40‘’。您已经完成十公里训练，休息一下吧！”<br>　　”啦啦啦！跑完啦~跑完了~腰也不酸，腿也不疼，脚也不痛。照这个节奏，跑个半马也没什么问题嘛。哥实在是太牛掰了！啊呀呀，做个胜利的手势吧！woc，手甩都了，举不起来。。。等会儿，刚才那坨翔哪去了Σ( ° △ °|||)“
　　</p>
<h3 id="一些没什么用的建议"><a href="#一些没什么用的建议" class="headerlink" title="一些没什么用的建议"></a>一些没什么用的建议</h3><ul>
<li><p>如果你想去跑步的话，装一个跑步记录的APP吧。推荐”悦跑圈“<del>约炮圈?</del>。运动记录，跑鞋里程记录，跑团，线上马拉松等等，个人觉得还是不错的。<del>那啥，我就不要广告费，反正没多少人看我的博客</del></p>
</li>
<li><p>如果你想去跑步的话，买一双自己能力范围内最好的专业跑鞋吧。不仅可以一定程度上提高成绩，还能够让你舍不得放弃这项运动，毕竟割肉买的。。<del>不说了，我去找点土来准备晚饭了</del></p>
</li>
<li><p>如果你想去跑步的话，不要跑跑停停，只要还能跑就跑下去。还有一点就是，一开始速度不要太快，毕竟相比于一开始跑得快后来被别人一一超过，还是一开始慢一点然后一个一个超过别人比较爽。</p>
</li>
<li><p><b><em>以上，纯属个人看法。</em></b>
　　</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。&lt;br&gt;
    
    </summary>
    
    
      <category term="跑步" scheme="http://hopsken.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
</feed>
