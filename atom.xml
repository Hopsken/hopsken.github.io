<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hopsken</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hopsken.com/"/>
  <updated>2017-08-21T06:56:38.000Z</updated>
  <id>http://hopsken.com/</id>
  
  <author>
    <name>Hopsken</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构学习笔记（JavaScript 描述）</title>
    <link href="http://hopsken.com/2017/08/20/javascript-data-stuctures/"/>
    <id>http://hopsken.com/2017/08/20/javascript-data-stuctures/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-21T06:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>数组<ol>
<li>常用方法</li>
<li>二维数组</li>
</ol>
</li>
<li>列表</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>字典</li>
<li>散列</li>
<li>集合</li>
</ol>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义是：一个存储元素的线性集合，元素可以通过索引任意存取。索引通常是数字。然而在 JavaScript 中，数组是一种特殊的对象，索引为该对象的属性，而 JavaScript 中对象的属性名必须是字符串类型。看上去很奇怪，不过也正因此，数组可以作为其他数据结构的基础。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>创建数组的方法有很多，不过一般推荐使用 [] 操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = []</div><div class="line"></div><div class="line">nums.unshift(num)   <span class="comment">//在开头添加元素</span></div><div class="line">nums.shift(num)     <span class="comment">//删除开头元素</span></div><div class="line">nums.pop()          <span class="comment">//删除末尾元素</span></div><div class="line">nums.push(num)      <span class="comment">//在末尾添加元素</span></div><div class="line">nums.splice(start, n, elements)     <span class="comment">//在中间 `start` 位置删除 n 个元素，并添加若干个 elements。</span></div><div class="line">nums.reverse()      <span class="comment">//反序</span></div><div class="line">nums.sort()         <span class="comment">//将数字从小到大排序</span></div></pre></td></tr></table></figure></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>按照《JavaScript 精髓》一书中的做法，通过扩展 JavaScript 数组对象实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.matrix = <span class="function"><span class="keyword">function</span>(<span class="params">numrows, numcols, initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numrows; ++i) &#123;</div><div class="line">        <span class="keyword">var</span> columns = []</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; numcols; ++j) &#123;</div><div class="line">            columns[j] = initial</div><div class="line">        &#125;</div><div class="line">        arr[i] = columns</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是一组有序的数据，适合用于保存的数据不太多时。</p>
<p>列表的抽象数据类型定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">listSize pos length </div><div class="line">insert() append() remove() clear()</div><div class="line">front() end() currPos() moveTo()</div><div class="line">prev() next() hasPrev() hasNext() </div><div class="line">toString() getElement() contains()</div></pre></td></tr></table></figure></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问。遵循<em>后入先出</em>的数据结构。因此，只能访问栈顶的元素，即最后加入的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">push()  //向栈内压入元素</div><div class="line">pop()   //删除栈顶元素</div><div class="line">peek()  //返回栈顶元素而不删除它</div></pre></td></tr></table></figure></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种列表，不同的是队列遵循<em>先进先出</em>的数据结构，即只能在队尾插入元素，在队首删除元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enqueue()   //向队尾插入元素，即 push()</div><div class="line">dequeue()   //删除队首元素，即 shift()</div><div class="line">front()     //返回队首元素</div><div class="line">back()      //返回队尾元素</div></pre></td></tr></table></figure></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>与列表的是，链表的底层数据结构不是数组，而是节点。与数组相比，链表的性能更加优越。缺陷是不方便进行随机访问。数组元素通过位置来进行引用，而链表元素则通过相互关系来引用。每一个节点都包含元素数据和指向下个节点的链接。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node 类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = element</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 链表类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>)    <span class="comment">//初始化头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find        <span class="comment">//查找</span></div><div class="line">    <span class="keyword">this</span>.insert = insert    <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.remove = remove    <span class="comment">//移除节点</span></div><div class="line">    <span class="keyword">this</span>.display = display  <span class="comment">//显示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fiqmm75lt4j30e806mq2r.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fiqmm6s1thj30hl058a9v.jpg" alt=""></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了能够方便的从后往前遍历，为每个节点添加指向前驱的链接。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node 类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = element</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.previous = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>与单向列表相似，唯一的区别在于初始化链表时，头节点的 next 属性指向它本身。这种行为会传导下去，这样，链表的尾节点就会指向头节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>)    <span class="comment">//初始化头节点</span></div><div class="line">    head.next = head    <span class="comment">// 头节点 next 属性指向自身</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典通过<em>键-值对</em>来存储数据。可以利用 JavaScript Object 类本身的特性来实现 Dictionary 类。使用 () 操作符来引用，而不是 []。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.datastore = []</div><div class="line">    <span class="keyword">this</span>.add = add  <span class="comment">// add(key, value)，即 this.datastore[key] = value</span></div><div class="line">    <span class="keyword">this</span>.find = find</div><div class="line">    <span class="keyword">this</span>.remove = remove</div><div class="line">    <span class="keyword">this</span>.showAll = showAll</div><div class="line">    <span class="keyword">this</span>.count = count</div><div class="line">    <span class="keyword">this</span>.clear = clear</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>散列是一种可以快速插入或取用的数据存储技术。散列使用的数据结构称为<em>散列表</em>。使用散列表存储时，通过有个<em>散列函数</em>讲键映射为一个数字，数字范围是 0 到散列表的长度。散列表的长度是预先定义的，一般取质数。当两个值映射到同一个值时则会发生<em>碰撞</em>。</p>
<h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>除留余数法：最简单的方法。以数组的长度对键取余（当键值为字符串时取其 ASCII 码之和），为了尽量避免结果相等发生碰撞，所以数组长度一般取质数。</p>
<p>霍纳算法：除留余数法很容易会发生碰撞。而霍纳算法则可以更好地避免这个问题。霍纳算法仍然计算字符串中各个字符的 ASCII 码值，不过在求和时每次都要乘一个质数，一般建议使用一个较小的质数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HornerHash</span>(<span class="params">string, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> H = <span class="number">31</span></div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;string.length; ++i) &#123;</div><div class="line">        total += H*total + string.charCodeAt(i)</div><div class="line">    &#125;</div><div class="line">    total = total % arr.length</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(total)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>开链法：在实现散列表的底层数组时，每个数组元素又是一个新的数据结构，这样就可以存储多个键了，当两个键散列后的数值相同时，依然可以保存在相同的位置。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fircfylz5bj30c407h743.jpg" alt="开链法"></p>
<p>线性探测法：线性探测法属于一种更一般的散列技术：<em>开放寻址散列</em>。当发生碰撞时，线性探测法会检查散列表中下一个位置是否为空，如果为空，则填入数据，否则，继续检查下一个位置，知道找到空位并填入。</p>
<p>一般来说，如果数组的大小是到存储数据个数的1.5倍，则使用开链法。如果数组大小为待存储数据的两倍及以上，则使用线性探测法。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一种包含不同元素的数据结构。集合具有两个特性。首先，集合元素是无序的，其次，集合中不允许相同成员存在。</p>
<p>集合的几个基本操作：并集、交集、补集、子集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="http://hopsken.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择器</title>
    <link href="http://hopsken.com/2017/06/04/CSS-selector/"/>
    <id>http://hopsken.com/2017/06/04/CSS-selector/</id>
    <published>2017-06-03T16:00:00.000Z</published>
    <updated>2017-08-14T04:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一个练习 CSS 选择器的小游戏 <a href="https://flukeout.github.io/" target="_blank" rel="external">CSS Diner</a>。<br><a id="more"></a></p>
<ol>
<li><p>标签选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h2 &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.className &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ID 选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#id &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>属性选择器</p>
<ol>
<li><p>简单属性匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[href] &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据具体属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[href=&quot;google.com&quot;] &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据部分属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[href~=&quot;google.com&quot;] &#123; &#125;</div></pre></td></tr></table></figure>
<p>其他一些匹配模式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo^="bar"]</span> <span class="comment">/*匹配开头*/</span> </div><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo$="bar"]</span> <span class="comment">/*匹配结尾*/</span></div><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo*="bar"]</span> <span class="comment">/*包含*/</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>后代（上下文）选择器</p>
<ol>
<li>选择后代元素</li>
<li><p>选择子元素 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h1 &gt; strong &#123; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>选择兄弟元素 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h1 + p &#123; &#125; /* 选择紧接在一个 h1 元素后出现的所以段落，h1 与 p 有相同的父元素 */</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>伪类选择器和伪元素选择器</p>
<ol>
<li><p>伪类选择器 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a:visited &#123;color: red;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>静态伪类<br><code>:link  :visited :first-child</code><br>   <code>:first-child</code>伪类：用于选择作为某个未知元素的第一个子元素的指定元素。<br>  <code>:lang(fr)</code>伪类：根据元素的语言来选择。不同于 <code>|=</code>属性选择器，<code>lang</code>的语言信息由属性与 META 信息提供，甚至可能包括 HTTP 头信息。</li>
<li><p>动态伪类<br><code>:focus :hover :active</code></p>
<p>结合伪类<br>推荐顺序：<code>link-visited-focus-hover-active</code></p>
</li>
</ul>
</li>
<li><p>伪元素选择器</p>
<ul>
<li><p>设置首字母样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p:first-letter &#123;font-size: 200%&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设置首行样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p:first-line &#123; &#125;</div></pre></td></tr></table></figure>
<p><em>需要注意的是，应用<code>:first-letter :first-line</code>的元素允许的属性是有限制的。</em></p>
</li>
<li>设置之前和之后元素的样式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">h2:before &#123;content:&quot; &quot;&#125;</div><div class="line">h2:after &#123; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一个练习 CSS 选择器的小游戏 &lt;a href=&quot;https://flukeout.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Diner&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://hopsken.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Note Taking Skills</title>
    <link href="http://hopsken.com/2017/02/05/Note-Taking-Skills/"/>
    <id>http://hopsken.com/2017/02/05/Note-Taking-Skills/</id>
    <published>2017-02-04T16:00:00.000Z</published>
    <updated>2017-02-05T04:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>Mindmap:<br><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fcfgpog614j310q0guwkp.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Mindmap:&lt;br&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006tNbRwgy1fcfgpog614j310q0guwkp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Tutorial" scheme="http://hopsken.com/tags/Tutorial/"/>
    
      <category term="Academic" scheme="http://hopsken.com/tags/Academic/"/>
    
  </entry>
  
  <entry>
    <title>Xcode8 中 CocoaPods 与 Swift 3.0 的适配问题</title>
    <link href="http://hopsken.com/2016/12/13/Xcode8-CocoaPods-Swift-3.0-problem-fix/"/>
    <id>http://hopsken.com/2016/12/13/Xcode8-CocoaPods-Swift-3.0-problem-fix/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2016-12-13T09:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多童鞋可能会遇到这样的问题：明明使用的 Swift 3 版本的库（比如 Alamofire 的 4.0.0 版本），但是使用 CocoaPods 安装之后打开 Xcode 仍然会提示 转换为 Swift 3，一路 Next 确认后各种报错。</p>
<p>有童鞋提出一种解决方法，就是在项目设置里把 “Use Legacy Swift Language Version” 改为 No。经本人测试后，发现有些时候这样改过之后就能编译通过了，但是有时候仍然会报错。怎么彻底解决这个问题呢？<br><a id="more"></a></p>
<p>遂StackOverFlow之。原来在 CocoaPods 1.1.1 版本中已经解决了这个问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>更新CocoaPods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods --pre</div></pre></td></tr></table></figure></p>
<p>在 Podfile 中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">post_install do |installer|</div><div class="line">  installer.pods_project.targets.each do |target|</div><div class="line">    target.build_configurations.each do |config|</div><div class="line">      config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.0&apos;</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>运行 <code>pod install</code> 即可。</p>
<p>再次打开项目，这时候就能够顺利编译通过啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多童鞋可能会遇到这样的问题：明明使用的 Swift 3 版本的库（比如 Alamofire 的 4.0.0 版本），但是使用 CocoaPods 安装之后打开 Xcode 仍然会提示 转换为 Swift 3，一路 Next 确认后各种报错。&lt;/p&gt;
&lt;p&gt;有童鞋提出一种解决方法，就是在项目设置里把 “Use Legacy Swift Language Version” 改为 No。经本人测试后，发现有些时候这样改过之后就能编译通过了，但是有时候仍然会报错。怎么彻底解决这个问题呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://hopsken.com/tags/Swift/"/>
    
      <category term="CocoaPods" scheme="http://hopsken.com/tags/CocoaPods/"/>
    
      <category term="Xcode" scheme="http://hopsken.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>我的 Chrome 插件</title>
    <link href="http://hopsken.com/2016/11/21/my-chrome-extensions/"/>
    <id>http://hopsken.com/2016/11/21/my-chrome-extensions/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-03-19T05:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>1Password<br> 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～</p>
</li>
<li><p>Adblock Plus<br> 大名鼎鼎的ABP！广告？那是什么？</p>
</li>
<li><p>Instapaper<br> Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。<a id="more"></a></p>
</li>
<li><p>Isometric Contributions<br> 让你的 Github 贡献看起来更美观～<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03fyxrccj30hs0b4wfi.jpg" alt="" title="Isometric Contributions"></p>
</li>
<li><p>JSON Formatter<br> 更美观的 JSON 输出，调试 API 的时候很方便。<br> <img src="http://ww2.sinaimg.cn/large/006tNc79gw1fa03l92tu2j30hs0b4wg3.jpg" alt="" title="JSON Formatter"></p>
</li>
<li><p>Octotree<br> 像浏览本地文件夹一样浏览 Github Repo<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03muhx87j31e00wrtgp.jpg" alt="" title="Octotree"></p>
</li>
<li><p>RatherNice<br> 一个可以让你心情好起来的新标签页插件～<br> <img src="https://ww2.sinaimg.cn/large/006tKfTcly1fds2aqps4sj30zk0m8ta6.jpg" alt="" title="RatherNice"></p>
</li>
<li><p>Stylebot<br> 可以任意修改网站的 CSS 来让网站看起来更舒服，也可以用来屏蔽广告。你还可以使用别人分享的 CSS 风格，当然你也可以自己设计并分享给其他人。</p>
</li>
<li><p>v2ex plus<br> v2ex的插件。对于一个经常逛V站的人来说几乎必备。</p>
</li>
<li><p>Vimium<br>如果你是 Vim 党，你一定会喜欢这个插件的！你可以像在 Vim 里一样，使用快捷键来控制网页滚动、跳转、搜索等等，极大提高工作效率。</p>
</li>
<li><p>Wappalyzer<br>用来分析网站的架构。前端工程师必备。</p>
</li>
<li><p>印象笔记·剪藏<br>把当前网页内容收藏到印象笔记里面，填充自己的资料库。</p>
</li>
<li><p>印象笔记·悦读<br>印象笔记的另一款插件。提供更舒服的阅读体验。</p>
</li>
<li><p>高效网页截图编辑插件<br>一款强大的网页截图工具。开发者也很有趣。</p>
</li>
<li><p>AdF.ly Skipper<br>跳过AdF.ly的一个工具。之前玩 Minecraft 下载mod的时候经常会用到。</p>
</li>
</ol>
<p>最后，安利一款 chrome 主题：<a href="https://chrome.google.com/webstore/detail/slinky-brushed/piiokbhpgldooopjdacdondngonfljoc?hl=zh-CN" target="_blank" rel="external"> Slinky </a>，换来换去最喜欢的还是这个！</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;1Password&lt;br&gt; 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adblock Plus&lt;br&gt; 大名鼎鼎的ABP！广告？那是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instapaper&lt;br&gt; Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。
    
    </summary>
    
    
      <category term="Chrome" scheme="http://hopsken.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>如何快速地写一篇博客</title>
    <link href="http://hopsken.com/2016/11/06/how-to-write-a-blog-quickly/"/>
    <id>http://hopsken.com/2016/11/06/how-to-write-a-blog-quickly/</id>
    <published>2016-11-05T16:00:00.000Z</published>
    <updated>2016-11-06T04:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候我们在开始写一篇博客的时候会觉得无从下手，不知道从何写起。好吧，至少我是这样的。这个时候我们就会想，要是写博客也有模版可以套用多好啊。就像WordPress的模版一样，只要套用一下，然后“duang”的一下，一篇博客就写好了，多好。不过，这终究是不切实际的幻想，写文章哪有什么模版，我们又不是在写八股文，最终我们还是得绞尽脑汁攒出一篇博文。当然，如果你“文思如尿崩，谁与我争锋”的话，那么就无需再看下去了。<br><a id="more"></a><br>虽然写文章没什么模版，但是，可以有套路啊！机缘巧合，我发现了一个叫“SCQA”的，又叫金字塔原则。它可以让你像写故事一样，来写一篇博文，但又不局限于博文，你甚至可以用这个方法来写书写论文。</p>
<p>那么SCQA到底是什么意思呢？各位看官莫急，容我慢慢道来：</p>
<ul>
<li>S （situation） - 描述现有的情况</li>
<li>C （complexity）- 进一步详细阐述情况的复杂性</li>
<li>Q（question）- 针对当前情景阐明现有的问题</li>
<li>A（answer）- 提出问题的解决方法</li>
</ul>
<p>下面具体解释一下每个部分写些什么。</p>
<h4 id="Situation"><a href="#Situation" class="headerlink" title="Situation"></a>Situation</h4><p>这个部分主要陈述关于要讲的话题的现状，可以是读者已经知道的。主要作用是讲读者引入到话题中，为接下来的讨论建立基础。</p>
<h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><p>这个部分主要解释当前要讨论问题的复杂性，对话题进一步分析，引导读者加入思考，问接下来问题的提出奠定基础。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p>经过上一部分的具体分析，自然而然地提出要讨论的问题。</p>
<h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h4><p>这是文章的<em>主要</em>部分。着重阐述自己针对问题的看法。尝试在开始的时候总结你的观点，然后再对细节进行细致地阐释。</p>
<p>以上便是SCQA写作结构的大概思路。可以看出，这种结构属于典型的西式思维，直来直去。这样写的好处在于逻辑清晰，结构严密，个人认为非常适合技术类文章的写作，直击问题，简洁明了。</p>
<p>最后，SCQA的写作方法也有其局限性，比如缺失了些许含蓄美。所以，个人还是在自己文思枯竭的时候才会用到。毕竟，博客是个展现个性的地方，更多的时候可能还是写给自己看的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候我们在开始写一篇博客的时候会觉得无从下手，不知道从何写起。好吧，至少我是这样的。这个时候我们就会想，要是写博客也有模版可以套用多好啊。就像WordPress的模版一样，只要套用一下，然后“duang”的一下，一篇博客就写好了，多好。不过，这终究是不切实际的幻想，写文章哪有什么模版，我们又不是在写八股文，最终我们还是得绞尽脑汁攒出一篇博文。当然，如果你“文思如尿崩，谁与我争锋”的话，那么就无需再看下去了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记第一次十公里跑</title>
    <link href="http://hopsken.com/2016/03/27/1000m-running/"/>
    <id>http://hopsken.com/2016/03/27/1000m-running/</id>
    <published>2016-03-26T16:00:00.000Z</published>
    <updated>2016-10-04T10:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。<br>    <a id="more"></a><br>　　我是从新年过后才开始跑步的，到现在为止差不多一个多月了。差不多每周跑四次，每次至少五公里。截止目前，累计距离72.44公里，跑步记录14次。所以，我目前最多只能算是一个初级跑者。现在的目标是半年内完成一次半程马拉松，大学四年内至少完成三次全程马拉松。说起我跑步的原因，首先是为了减肥（我想这也是多数跑者开始跑步的原因吧）再者，是因为读了村上春树的《当我谈跑步时我谈些什么》，颇受触动，为其精神所感染。后来，不知从第几次跑步开始，我开始喜欢上了这项运动。我喜欢上了两公里时候脚酸的要死的感觉，喜欢上了四公里时腿重得像灌了铅的感觉，喜欢上了耳机里“您已经跑了五公里”的提示音，喜欢了五公里后多跑的每一百米。总之，不管愿不愿意，我已经爱上了跑步。</p>
<h3 id="10KM准备"><a href="#10KM准备" class="headerlink" title="10KM准备　"></a>10KM准备　</h3><p>　　在跑过十次五公里之后，我决定挑战一下10KM跑。时间是周日上午，地点是学校网球场旁的跑道。<br>　　<br>　　在经过了两天的休整之后，周日如期而至。九点起床，舍友还在酣睡之中；洗漱，特地把脸洗了两遍；吃早饭，还是以前吃的那些；顺道去食堂旁的小商店买了一瓶矿泉水以及一袋彩虹糖。认真地翻看网上找到的跑前拉伸动作。毕竟是第一次跑十公里，不能像以前跑五公里的时候那样只在跑完后做一下简单拉伸，不能太随意。<br>　　<br>　　终于来到了操场。因为是周日，操场没什么人。只有几个家长在带着孩子打网球，还有路过的去操场旁边的成人教育楼上课的人们。在做了十分钟的准备活动之后，就正式开始了我的十公里征程啦！<br>　　<br>　　因为不是标准化田径场，绕操场一圈的距离没具体测过，大概是300米吧。那么10KM就是要绕着跑三四十圈了。额，听起来有点吓人啊。不过，反正咱是慢跑，而且既然之前跑五公里跑完之后也不是很累，所以应该没什么问题吧。只要能保持6‘30’‘的配速，应该没什么问题的。</p>
<h3 id="以下内容纯属意识流"><a href="#以下内容纯属意识流" class="headerlink" title="以下内容纯属意识流"></a>以下内容纯属意识流</h3><p>　　“您已经跑了一公里，用时6’14‘’，剩余距离9公里”<br>　　“啊，已经跑了一公里了啊。今天有点冷啊。。再多跑几步应该就会暖和起来了吧。”<br>　　<br>　　“您已经跑了两公里，用时6‘38‘’，剩余距离8公里”<br>　　“已经跑了五分之一了啊！加油加油！哎，那边那个打网球的技术好烂啊。”<br>　　<br>　　“您已经跑了三公里，用时6‘28‘’，剩余距离7公里”<br>　　“哎呀，已经三公里了哎，差不多三分之一。奇怪，按理说这个时候腿已经开始酸了，今天怎么没有，难道是因为今天跑之前做足了拉伸。也许吧。看来今天状态不错嘛，跑个十公里应该没问题。哈哈哈”<br>　　<br>　　“您已经跑了四公里，用时6‘28’‘，剩余距离6公里”<br>　　“哟嚯，又是6’28‘’，记得上一公里也是花了这么长时间，看来速度控制的不错嘛。嗯，腿和脚都没有酸痛的感觉，nice！啊呀，这里有一坨‘犬之翔’哎。woc，还好没踩到。还好我机智，哈哈哈。”<br>　　<br>　　“您已经跑了五公里，用时6‘30’‘，剩余距离5公里”<br>　　“已经跑了五公里了啊，一半了哎，平时这个时候都可以停下来了。 嗯，目前看来，耐力和体力都没什么问题。加油吧！噫，这坨翔怎么还在这里。”<br>　　<br>　　“您已经跑了六公里，用时6’42‘’，剩余距离4公里”<br>　　“六公里了哈。woc，竟然有个妹子在男生宿舍门口，手里还拎了个星巴克的咖啡。好烦，可恶的情侣= =算了，我还是跑自己的步，懒得理你们。Hello，翔，你还在啊。”<br>　　<br>　　“您已经跑了七公里，用时6‘24’‘，剩余距离3公里”<br>　　“哎呀，我去，怎么还有三公里……一不小心就跑了45分钟了，我实在是太棒了！哈哈哈！呦，又有家长带着小孩来玩。哟嚯，不错啊，大叔，这么大啤酒肚玩的了单杠，给你竖个大拇指。额，还是不竖了吧，人家会觉得我是傻X吧。。”<br>　　<br>　　“您已经跑了八公里，用时6’34‘’，剩余距离2公里”<br>　　“八公里，还有两公里，哎呀，好烦啊，怎么还有两公里，妈呀，我不想跑了啊，老这么跑好无聊啊。前面那个跑超过我的那个女生，真是太不上路子了，哥这是在跑十公里好吗？十公里ok？我跑了这么久，你才跑一会儿，你怎么好意思跑超过我呢？你这样让我很难堪好吗？那啥，前面的那两个熊孩子让一让，挡住我的路了。算了，还是我让过去吧。。。woc，怎么这坨翔还在这里。”<br>　　<br>　　“您已经跑了九公里，用时6‘36’‘，剩余距离1公里，加油！”<br>　　“还有最后一公里啊，坚持下来都可以了！哎呀，一不小心就跑了将近一个小时了啊。哥实在是太厉害了！等会回去一定要把这次跑步写下来！嗯，等马上跑完，我要好好秀一秀😏”<br>　　<br>　　“您已经跑了十公里，用时6’40‘’。您已经完成十公里训练，休息一下吧！”<br>　　”啦啦啦！跑完啦~跑完了~腰也不酸，腿也不疼，脚也不痛。照这个节奏，跑个半马也没什么问题嘛。哥实在是太牛掰了！啊呀呀，做个胜利的手势吧！woc，手甩都了，举不起来。。。等会儿，刚才那坨翔哪去了Σ( ° △ °|||)“
　　</p>
<h3 id="一些没什么用的建议"><a href="#一些没什么用的建议" class="headerlink" title="一些没什么用的建议"></a>一些没什么用的建议</h3><ul>
<li><p>如果你想去跑步的话，装一个跑步记录的APP吧。推荐”悦跑圈“<del>约炮圈?</del>。运动记录，跑鞋里程记录，跑团，线上马拉松等等，个人觉得还是不错的。<del>那啥，我就不要广告费，反正没多少人看我的博客</del></p>
</li>
<li><p>如果你想去跑步的话，买一双自己能力范围内最好的专业跑鞋吧。不仅可以一定程度上提高成绩，还能够让你舍不得放弃这项运动，毕竟割肉买的。。<del>不说了，我去找点土来准备晚饭了</del></p>
</li>
<li><p>如果你想去跑步的话，不要跑跑停停，只要还能跑就跑下去。还有一点就是，一开始速度不要太快，毕竟相比于一开始跑得快后来被别人一一超过，还是一开始慢一点然后一个一个超过别人比较爽。</p>
</li>
<li><p><b><em>以上，纯属个人看法。</em></b>
　　</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。&lt;br&gt;
    
    </summary>
    
    
      <category term="跑步" scheme="http://hopsken.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python -- 使用第三方API查看LOL玩家数据</title>
    <link href="http://hopsken.com/2016/02/25/LOLGel/"/>
    <id>http://hopsken.com/2016/02/25/LOLGel/</id>
    <published>2016-02-24T16:00:00.000Z</published>
    <updated>2016-12-13T09:34:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>额，之所以会写这个脚本嘛，首先是因为晚自习实在无聊，其次因为舍友天天都在玩LOL，刚好今天下午看到有别人做的LOL的<a href="http://api.xunjob.cn/" target="_blank" rel="external">API</a>。于是，就顺手写了这个脚本。实现原理很简单，没什么可说的，只用到了Python的Requests库。说起来，Requests真心很好用啊 😄</p>
<a id="more"></a>
<p>代码如下:</p>
<pre>
#-*- coding: utf-8 -*-
#LOLGel
#Version: 0.0.1
#Authored By Hopsken
#Website: https://7pp.org

import requests

serverName = raw_input("> 请输入服务器大区名称...")
playerName = raw_input("> 请输入召唤师昵称...")

payload = {'serverName': '皮城警备', 'playerName': '龙龙瞎'}
payload["serverName"] = serverName
payload["playerName"] = playerName

print "\n"
print "服务器大区：", serverName, "召唤师：", playerName, "\n"

record = requests.get('http://API.xunjob.cn/Record.php', params=payload).json()['Record']
print "比赛记录: "
print record
print "\n"

playerInfo = requests.get('http://API.xunjob.cn/playerinfo.php', params=payload).json()
playerDuanwei = requests.get('http://API.xunjob.cn/rank.php', params=payload).json()["duanwei"]
playerLevel = int(playerInfo['level'])
playerPower = int(playerInfo["zhandouli"])
playerGood = playerInfo["good"]
print "玩家等级:  %r \n" % playerLevel
print "玩家段位: ", playerDuanwei, "\n"
print "玩家战斗力:  %r \n" % playerPower
print playerGood
print "\n"

oftenUsedHero = requests.get('http://API.xunjob.cn/hero.php', params=payload).json()["herostr"]
print "\n"
print "常用英雄列表："
for hero in oftenUsedHero:
    heroName = hero["attr"]["title"].split()[0]
    print "\t", heroName
print "\n"


heroData = requests.get('http://lolbox.duowan.com/new/api/index.php?_do=personal/championslist', params=payload).json()["content"]
print "英雄详细信息："
print "英雄名称\t英雄胜率\tMVP次数\t\t比赛场次\t平均击杀\t平均死亡\t平均助攻\t"
for hero in heroData:
    heroName = hero["championNameCN"]
    if len(heroName) == 3:
        heroName += " "
    elif len(heroName) == 2:
        heroName += " "*4
    winRate = hero["winRate"]
    matchStat = hero["matchStat"]
    averageK = hero["averageKDA"][0]
    averageD = hero["averageKDA"][1]
    averageA = hero["averageKDA"][2]
    totalMVP = hero["totalMVP"]
    print heroName, "\t", str(winRate)+"%","\t\t", totalMVP, "\t\t" ,matchStat,"\t\t",averageK, "\t\t", averageD, "\t\t", averageA

#这是用来统计调用次数的，不喜欢的话可以去掉
log = requests.get('https://7pp.org/lol.html')
</pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;额，之所以会写这个脚本嘛，首先是因为晚自习实在无聊，其次因为舍友天天都在玩LOL，刚好今天下午看到有别人做的LOL的&lt;a href=&quot;http://api.xunjob.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API&lt;/a&gt;。于是，就顺手写了这个脚本。实现原理很简单，没什么可说的，只用到了Python的Requests库。说起来，Requests真心很好用啊 😄&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://hopsken.com/tags/code/"/>
    
  </entry>
  
</feed>
