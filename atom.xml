<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hopsken</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hopsken.com/"/>
  <updated>2018-04-07T13:56:39.945Z</updated>
  <id>https://hopsken.com/</id>
  
  <author>
    <name>Hopsken</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解 JavaScript 继承与原型链</title>
    <link href="https://hopsken.com/2018/03/20/understand-prototype/"/>
    <id>https://hopsken.com/2018/03/20/understand-prototype/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-04-07T13:56:39.945Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多小伙伴在刚开始接触 JavaScript 的继承机制时都会感到一头雾水，特别是对于有面向对象编程语言（如Java，Python等）经验的同学。因为 JavaScript 本身不提供 class 实现，而是使用一种称作『原型链』的方法来模拟了类的继承。<br><a id="more"></a></p><p>要想理解原型链，首先需要知道的一点就是 JavaScript 是基于对象的。每一个对象都有一个私有属性<code>[[prototype]]</code>，它指向它的原型对象（prototype）。该原型对象又有一个自己的 prototype，层层向上直到一个对象的原型为<code>null</code>。这就是原型链，原型链的作用就是把这些对象联系起来。</p><h2 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h2><p>构造函数本质上就是函数声明，与普通函数不同的是，我们人为地使用首字母大写来将其与普通函数区分开。因为 JavaScript 中，函数本质上也是对象，所以构造函数具有 <code>prototype</code> 属性。我们可以利用这一点模拟出类的继承。</p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>为了更好的理解，我们来举个栗子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//定义一个 Cat 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将 Cat 原型指向一个对象</span></div><div class="line"><span class="comment">//该对象定义了一个 meow 方法</span></div><div class="line">Cat.prototype = &#123;</div><div class="line">    <span class="attr">meow</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"meow meow meow~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过 new 关键字创建两个 Cat 实例</span></div><div class="line"><span class="keyword">let</span> kitty = <span class="keyword">new</span> Cat(<span class="string">"Kitty"</span>);</div><div class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>);</div><div class="line"></div><div class="line">kitty.name          <span class="comment">//=&gt;"Kitty"</span></div><div class="line">tom.name            <span class="comment">//=&gt;"Tom"</span></div><div class="line">kitty.meow()        <span class="comment">//=&gt;"meow meow meow~~"</span></div><div class="line">tom.meow()          <span class="comment">//=&gt;"meow meow meow~~"</span></div></pre></td></tr></table></figure><p>当我们调用实例对象的属性和方法时，JavaScript 会先尝试在当前对象自有的属性和方法中查找，如果没有，则会去该对象的原型，即 <code>prototype</code> 指向的对象中查找，并以此类推。如果直到原型链的终端 <code>null</code> 都没有，则返回 <code>undefined</code>。因此当调用 <code>meow</code> 方法时，因为构造函数中没有定义此方法，所以 JavaScript 会去对象的原型中查找 <code>meow</code> 方法。这样就实现了在各个实例间共享方法。</p><p>注意：当我们调用继承的属性时，<code>this</code> 始终指向当前继承的对象，而不是继承的函数所在的原型对象。因此当我们调用 <code>name</code> 属性时，会返回对应的属性值。</p><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>每一个 JavaScript 对象（<code>null</code>除外）都会有一个 <code>__proto__</code> 属性。如果说 <code>prototype</code> 属性表达了构造函数和实例原型之间的关系，那么 <code>__proto__</code> 表明了实例与实例原型之间的关系。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">kitty.__proto__ === Cat.prototype   <span class="comment">//=&gt;true</span></div><div class="line"></div><div class="line"><span class="comment">//ES5中定义的另一个获取对象原型的方法</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(kitty) === Cat.prototype  <span class="comment">//=&gt;true</span></div></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>对象还有另外一个属性 <code>constructor</code> 。与 <code>prototype</code> 相反，<code>constructor</code> 是原型的属性，指向该原型的构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Cat.prototype.constructor === Cat   <span class="comment">//=&gt;true</span></div></pre></td></tr></table></figure><p>详细关系图如下，摘自<a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">Github: mqyqingfeng/Blog</a><br><img src="https://o8r4eescd.qnssl.com/15217112091355.png" alt=""></p><h3 id="new-的时候发生了什么？"><a href="#new-的时候发生了什么？" class="headerlink" title="new 的时候发生了什么？"></a>new 的时候发生了什么？</h3><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN </a>上的解释：当代码 new Foo(…) 执行时，会发生以下事情：</p><ol><li>一个继承自 Foo.prototype 的新对象被创建。</li><li>使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol><p>举例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car(<span class="string">"Porsche"</span>)</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> car = (<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> ret = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</div><div class="line">        ret.__proto__ = func.prototype</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> ret1 = func.apply(ret, [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ret1 === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret1 === <span class="string">"function"</span> &amp;&amp; ret1 !== <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ret1;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;)(Car, <span class="string">"Porsche"</span>)</div></pre></td></tr></table></figure><h2 id="使用Object-create-方法"><a href="#使用Object-create-方法" class="headerlink" title="使用Object.create()方法"></a>使用Object.create()方法</h2><p>ES5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div></pre></td></tr></table></figure><h2 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 class 关键字</h2><p>ES6 中引入了一套新的关键字用来实现 <code>class</code>，但它仍然是基于原型的。详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类 - MDN</a>。</p><p><em>参考资料：</em></p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链 - MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create() - MDN</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想 - 阮一峰的网络日志</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">mqyqingfeng/Blog - Github</a></li><li><a href="https://blog.oyanglul.us/javascript/understand-prototype.html" target="_blank" rel="noopener">理解JavaScript的原型链和继承 - blog.oyanglul.us</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多小伙伴在刚开始接触 JavaScript 的继承机制时都会感到一头雾水，特别是对于有面向对象编程语言（如Java，Python等）经验的同学。因为 JavaScript 本身不提供 class 实现，而是使用一种称作『原型链』的方法来模拟了类的继承。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://hopsken.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://hopsken.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 单位与百分比值详述</title>
    <link href="https://hopsken.com/2018/03/18/CSS-units/"/>
    <id>https://hopsken.com/2018/03/18/CSS-units/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-03-22T10:08:35.376Z</updated>
    
    <content type="html"><![CDATA[<p>单位是我们控制尺寸的重要工具，也是我们在编写 CSS 代码时会经常使用到的。CSS 的单位主要分成两种：绝对单位和相对单位。<a id="more"></a></p><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>CSS 中的绝对单位包括：mm（毫米），cm（厘米），in（英寸），pt（点），pc（派卡）。</p><ul><li>mm，cm，in 这三个都很好理解，就是我们拿着尺子对着屏幕量出来的真实宽度。不过说起来，现在全世界貌似只有美帝还在使用英寸作为长度单位，从侧面也可以看出美帝的影响力。（1英寸=2.54厘米）</li><li>pt 和 pc 这两个倒是不怎么常见。其中，pt（点）其实是一种标准印刷度量单位，长度上1英寸=72点。pc（派卡）也是印刷术语，1派卡=12点=1/6英寸。</li></ul><p>事实上，我们很少需要用到绝对单位。因为一般来说我们网页需要在各种不同大小的屏幕上显示，使用绝对长度很难确保内容显示的一致性。</p><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>CSS 中的相对长度单位包括：px（像素），em，ex，ch，rem，vw，vh，vmin，vmax</p><ul><li>px（像素），像素就是显示器上的一个点。关于 px 是相对长度单位还是绝对长度单位这一点有争议，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Values_and_units" target="_blank" rel="noopener">MDN</a>把 px 归为绝对单位，而《CSS权威指南（第三版）》中则把它归为相对单位（因为取决于显示设备的分辨率）。</li><li>em，ex，ch。1em 被定义为一种给定字体的 font-size 值。比方说一个元素的 font-size 为 20px，那么对于这个元素，1em=20px。另外如果没有为当前元素指定 font-size，但是因为font-size值是会继承的，所以会取父元素的值。举个栗子：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum <span class="tag">&lt;<span class="name">span</span>&gt;</span>foo bar<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">div &#123;font-size: 20px;&#125;</div><div class="line">p &#123;font-size: 1.2em;&#125; //计算值为 20px*1.2 = 24px</div><div class="line">span &#123;font-size: 0.8em;&#125; //计算值为 20px*1.2*0.8=19.2px</div></pre></td></tr></table></figure><ul><li>ex，ch。理论上，ex 是指所用字体中小写 x 的高度，ch 是指所用字体 0 的宽度，但是浏览器对两个单位的支持有限，很多浏览器的实际做法是取1ex=0.5em。</li><li>rem，即 root em，是 CSS 3中新定义的单位。与 em 类似，不过 rem 永远是以默认基础字体大小为参照的，继承的字体大小不会影响它。我们可以基于rem这一特性构建出响应式布局。一般浏览器默认的字体大小都是16px。</li><li>vw，vh，即 viewport width 和 viewport height，也是 CSS 3 中新添加的单位。1vw = 1/100 视口宽度（viewport width），1vh = 1/100视口高度（viewport height）。</li><li>vmin，vmax，这两个也是 CSS 3 新定义的视口单位。其中，vmin 取 vw 与 vh 中较小的那个单位，vmax 则相反取较大的那个。</li></ul><h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>百分比值是 CSS 中非常常用的一种数值，也是很多新手很容易困惑的地方。形式上百分比值就是实数+百分号（%）。因为百分比值几乎总是相对于另一个值的，而对于不同的属性，选择的参考值也是不同的，所以得到的计算值也会不同。</p><p>要想真正掌握百分比值的计算，首先要了解<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/All_About_The_Containing_Block" target="_blank" rel="noopener">包含块（MDN）</a>的概念。大多数情况下，包含块就是父级块元素的 content 区域，即内容区。</p><table><thead><tr><th style="text-align:left">参照值</th><th style="text-align:left">属性</th></tr></thead><tbody><tr><td style="text-align:left">包含块宽度</td><td style="text-align:left">[max/min-]width、left、right、text-indent、padding-*、margin-* 等</td></tr><tr><td style="text-align:left">包含块高度</td><td style="text-align:left">[max/min-]height、top、bottom 等</td></tr><tr><td style="text-align:left">继承字号</td><td style="text-align:left">font-size 等</td></tr><tr><td style="text-align:left">自身字号</td><td style="text-align:left">line-height 等</td></tr><tr><td style="text-align:left">自身行高</td><td style="text-align:left">vertical-align 等</td></tr><tr><td style="text-align:left">自身宽高</td><td style="text-align:left">border-*-*-radius 等</td></tr><tr><td style="text-align:left">边界框尺寸</td><td style="text-align:left">transform: translate() 等</td></tr><tr><td style="text-align:left">特殊情况</td><td style="text-align:left">background-position: 相对于背景区域尺寸减去背景图尺寸</td></tr></tbody></table><p><em>参考资料</em></p><ol><li><a href="https://www.amazon.cn/dp/B0011F5SIC/" target="_blank" rel="noopener">《CSS 权威指南（第三版）》</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Values_and_units" target="_blank" rel="noopener">CSS 的值和单位 - MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/All_About_The_Containing_Block" target="_blank" rel="noopener">All about the containing block - MDN</a></li><li><a href="https://web.archive.org/web/20150906065047/https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_percentage_values" target="_blank" rel="noopener">CSS percentage values - MDN</a> </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位是我们控制尺寸的重要工具，也是我们在编写 CSS 代码时会经常使用到的。CSS 的单位主要分成两种：绝对单位和相对单位。
    
    </summary>
    
      <category term="前端" scheme="https://hopsken.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://hopsken.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记（JavaScript 描述）</title>
    <link href="https://hopsken.com/2017/08/20/javascript-data-stuctures/"/>
    <id>https://hopsken.com/2017/08/20/javascript-data-stuctures/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-21T09:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。</p><a id="more"></a><blockquote><ol><li>数组<ol><li>常用方法</li><li>二维数组</li></ol></li><li>列表</li><li>栈</li><li>队列</li><li>链表</li><li>字典</li><li>散列</li><li>集合</li></ol></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义是：一个存储元素的线性集合，元素可以通过索引任意存取。索引通常是数字。然而在 JavaScript 中，数组是一种特殊的对象，索引为该对象的属性，而 JavaScript 中对象的属性名必须是字符串类型。看上去很奇怪，不过也正因此，数组可以作为其他数据结构的基础。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>创建数组的方法有很多，不过一般推荐使用 [] 操作符。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = []</div><div class="line"></div><div class="line">nums.unshift(num)   <span class="comment">//在开头添加元素</span></div><div class="line">nums.shift(num)     <span class="comment">//删除开头元素</span></div><div class="line">nums.pop()          <span class="comment">//删除末尾元素</span></div><div class="line">nums.push(num)      <span class="comment">//在末尾添加元素</span></div><div class="line">nums.splice(start, n, elements)     <span class="comment">//在中间 `start` 位置删除 n 个元素，并添加若干个 elements。</span></div><div class="line">nums.reverse()      <span class="comment">//反序</span></div><div class="line">nums.sort()         <span class="comment">//将数字从小到大排序</span></div></pre></td></tr></table></figure></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>按照《JavaScript 精髓》一书中的做法，通过扩展 JavaScript 数组对象实现。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Array</span>.matrix = <span class="function"><span class="keyword">function</span>(<span class="params">numrows, numcols, initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numrows; ++i) &#123;</div><div class="line">        <span class="keyword">var</span> columns = []</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; numcols; ++j) &#123;</div><div class="line">            columns[j] = initial</div><div class="line">        &#125;</div><div class="line">        arr[i] = columns</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是一组有序的数据，适合用于保存的数据不太多时。</p><p>列表的抽象数据类型定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">listSize pos length </div><div class="line">insert() append() remove() clear()</div><div class="line">front() end() currPos() moveTo()</div><div class="line">prev() next() hasPrev() hasNext() </div><div class="line">toString() getElement() contains()</div></pre></td></tr></table></figure></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问。遵循<em>后入先出</em>的数据结构。因此，只能访问栈顶的元素，即最后加入的元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">push()  //向栈内压入元素</div><div class="line">pop()   //删除栈顶元素</div><div class="line">peek()  //返回栈顶元素而不删除它</div></pre></td></tr></table></figure></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种列表，不同的是队列遵循<em>先进先出</em>的数据结构，即只能在队尾插入元素，在队首删除元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">enqueue()   //向队尾插入元素，即 push()</div><div class="line">dequeue()   //删除队首元素，即 shift()</div><div class="line">front()     //返回队首元素</div><div class="line">back()      //返回队尾元素</div></pre></td></tr></table></figure></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>与列表的是，链表的底层数据结构不是数组，而是节点。与数组相比，链表的性能更加优越。缺陷是不方便进行随机访问。数组元素通过位置来进行引用，而链表元素则通过相互关系来引用。每一个节点都包含元素数据和指向下个节点的链接。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Node 类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = element</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 链表类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>)    <span class="comment">//初始化头节点</span></div><div class="line">    <span class="keyword">this</span>.find = find        <span class="comment">//查找</span></div><div class="line">    <span class="keyword">this</span>.insert = insert    <span class="comment">//插入节点</span></div><div class="line">    <span class="keyword">this</span>.remove = remove    <span class="comment">//移除节点</span></div><div class="line">    <span class="keyword">this</span>.display = display  <span class="comment">//显示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fiqmm75lt4j30e806mq2r.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fiqmm6s1thj30hl058a9v.jpg" alt=""></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>为了能够方便的从后往前遍历，为每个节点添加指向前驱的链接。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Node 类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = element</div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.previous = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>与单向列表相似，唯一的区别在于初始化链表时，头节点的 next 属性指向它本身。这种行为会传导下去，这样，链表的尾节点就会指向头节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>)    <span class="comment">//初始化头节点</span></div><div class="line">    head.next = head    <span class="comment">// 头节点 next 属性指向自身</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典通过<em>键-值对</em>来存储数据。可以利用 JavaScript Object 类本身的特性来实现 Dictionary 类。使用 () 操作符来引用，而不是 []。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.datastore = []</div><div class="line">    <span class="keyword">this</span>.add = add  <span class="comment">// add(key, value)，即 this.datastore[key] = value</span></div><div class="line">    <span class="keyword">this</span>.find = find</div><div class="line">    <span class="keyword">this</span>.remove = remove</div><div class="line">    <span class="keyword">this</span>.showAll = showAll</div><div class="line">    <span class="keyword">this</span>.count = count</div><div class="line">    <span class="keyword">this</span>.clear = clear</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>散列是一种可以快速插入或取用的数据存储技术。散列使用的数据结构称为<em>散列表</em>。使用散列表存储时，通过有个<em>散列函数</em>讲键映射为一个数字，数字范围是 0 到散列表的长度。散列表的长度是预先定义的，一般取质数。当两个值映射到同一个值时则会发生<em>碰撞</em>。</p><h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>除留余数法：最简单的方法。以数组的长度对键取余（当键值为字符串时取其 ASCII 码之和），为了尽量避免结果相等发生碰撞，所以数组长度一般取质数。</p><p>霍纳算法：除留余数法很容易会发生碰撞。而霍纳算法则可以更好地避免这个问题。霍纳算法仍然计算字符串中各个字符的 ASCII 码值，不过在求和时每次都要乘一个质数，一般建议使用一个较小的质数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HornerHash</span>(<span class="params">string, arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> H = <span class="number">31</span></div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;string.length; ++i) &#123;</div><div class="line">        total += H*total + string.charCodeAt(i)</div><div class="line">    &#125;</div><div class="line">    total = total % arr.length</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(total)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>开链法：在实现散列表的底层数组时，每个数组元素又是一个新的数据结构，这样就可以存储多个键了，当两个键散列后的数值相同时，依然可以保存在相同的位置。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fircfylz5bj30c407h743.jpg" alt="开链法"></p><p>线性探测法：线性探测法属于一种更一般的散列技术：<em>开放寻址散列</em>。当发生碰撞时，线性探测法会检查散列表中下一个位置是否为空，如果为空，则填入数据，否则，继续检查下一个位置，知道找到空位并填入。</p><p>一般来说，如果数组的大小是到存储数据个数的1.5倍，则使用开链法。如果数组大小为待存储数据的两倍及以上，则使用线性探测法。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一种包含不同元素的数据结构。集合具有两个特性。首先，集合元素是无序的，其次，集合中不允许相同成员存在。</p><p>集合的几个基本操作：并集、交集、补集、子集。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的数据结构包括数组、列表、栈、队列、链表、字典、散列、集合等。每种数据结构都有其自己的特点。很多时候，选择一个恰当的数据结构，可以很大程度简化棘手的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="https://hopsken.com/tags/Note/"/>
    
      <category term="JavaScript" scheme="https://hopsken.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择器</title>
    <link href="https://hopsken.com/2017/06/04/CSS-selector/"/>
    <id>https://hopsken.com/2017/06/04/CSS-selector/</id>
    <published>2017-06-03T16:00:00.000Z</published>
    <updated>2017-08-14T04:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一个练习 CSS 选择器的小游戏 <a href="https://flukeout.github.io/" target="_blank" rel="noopener">CSS Diner</a>。<br><a id="more"></a></p><ol><li><p>标签选择器</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">h2 &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>类选择器</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.className &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>ID 选择器</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#id &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>属性选择器</p><ol><li><p>简单属性匹配</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a[href] &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>根据具体属性值</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a[href=&quot;google.com&quot;] &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>根据部分属性值</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a[href~=&quot;google.com&quot;] &#123; &#125;</div></pre></td></tr></table></figure><p>其他一些匹配模式:</p><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo^="bar"]</span> <span class="comment">/*匹配开头*/</span> </div><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo$="bar"]</span> <span class="comment">/*匹配结尾*/</span></div><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[foo*="bar"]</span> <span class="comment">/*包含*/</span></div></pre></td></tr></table></figure></li></ol></li><li><p>后代（上下文）选择器</p><ol><li>选择后代元素</li><li><p>选择子元素 </p> <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">h1 &gt; strong &#123; &#125;</div></pre></td></tr></table></figure></li><li><p>选择兄弟元素 </p> <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">h1 + p &#123; &#125; /* 选择紧接在一个 h1 元素后出现的所以段落，h1 与 p 有相同的父元素 */</div></pre></td></tr></table></figure></li></ol></li><li><p>伪类选择器和伪元素选择器</p><ol><li><p>伪类选择器 </p> <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a:visited &#123;color: red;&#125;</div></pre></td></tr></table></figure><ul><li>静态伪类<br><code>:link  :visited :first-child</code><br>   <code>:first-child</code>伪类：用于选择作为某个未知元素的第一个子元素的指定元素。<br>  <code>:lang(fr)</code>伪类：根据元素的语言来选择。不同于 <code>|=</code>属性选择器，<code>lang</code>的语言信息由属性与 META 信息提供，甚至可能包括 HTTP 头信息。</li><li><p>动态伪类<br><code>:focus :hover :active</code></p><p>结合伪类<br>推荐顺序：<code>link-visited-focus-hover-active</code></p></li></ul></li><li><p>伪元素选择器</p><ul><li><p>设置首字母样式</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">p:first-letter &#123;font-size: 200%&#125;</div></pre></td></tr></table></figure></li><li><p>设置首行样式</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">p:first-line &#123; &#125;</div></pre></td></tr></table></figure><p><em>需要注意的是，应用<code>:first-letter :first-line</code>的元素允许的属性是有限制的。</em></p></li><li>设置之前和之后元素的样式<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">h2:before &#123;content:&quot; &quot;&#125;</div><div class="line">h2:after &#123; &#125;</div></pre></td></tr></table></figure></li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一个练习 CSS 选择器的小游戏 &lt;a href=&quot;https://flukeout.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS Diner&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://hopsken.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的 Chrome 插件</title>
    <link href="https://hopsken.com/2016/11/21/my-chrome-extensions/"/>
    <id>https://hopsken.com/2016/11/21/my-chrome-extensions/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-03-19T05:00:35.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>1Password<br> 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～</p></li><li><p>Adblock Plus<br> 大名鼎鼎的ABP！广告？那是什么？</p></li><li><p>Instapaper<br> Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。<a id="more"></a></p></li><li><p>Isometric Contributions<br> 让你的 Github 贡献看起来更美观～<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03fyxrccj30hs0b4wfi.jpg" alt="" title="Isometric Contributions"></p></li><li><p>JSON Formatter<br> 更美观的 JSON 输出，调试 API 的时候很方便。<br> <img src="http://ww2.sinaimg.cn/large/006tNc79gw1fa03l92tu2j30hs0b4wg3.jpg" alt="" title="JSON Formatter"></p></li><li><p>Octotree<br> 像浏览本地文件夹一样浏览 Github Repo<br> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fa03muhx87j31e00wrtgp.jpg" alt="" title="Octotree"></p></li><li><p>RatherNice<br> 一个可以让你心情好起来的新标签页插件～<br> <img src="https://ww2.sinaimg.cn/large/006tKfTcly1fds2aqps4sj30zk0m8ta6.jpg" alt="" title="RatherNice"></p></li><li><p>Stylebot<br> 可以任意修改网站的 CSS 来让网站看起来更舒服，也可以用来屏蔽广告。你还可以使用别人分享的 CSS 风格，当然你也可以自己设计并分享给其他人。</p></li><li><p>v2ex plus<br> v2ex的插件。对于一个经常逛V站的人来说几乎必备。</p></li><li><p>Vimium<br>如果你是 Vim 党，你一定会喜欢这个插件的！你可以像在 Vim 里一样，使用快捷键来控制网页滚动、跳转、搜索等等，极大提高工作效率。</p></li><li><p>Wappalyzer<br>用来分析网站的架构。前端工程师必备。</p></li><li><p>印象笔记·剪藏<br>把当前网页内容收藏到印象笔记里面，填充自己的资料库。</p></li><li><p>印象笔记·悦读<br>印象笔记的另一款插件。提供更舒服的阅读体验。</p></li><li><p>高效网页截图编辑插件<br>一款强大的网页截图工具。开发者也很有趣。</p></li><li><p>AdF.ly Skipper<br>跳过AdF.ly的一个工具。之前玩 Minecraft 下载mod的时候经常会用到。</p></li></ol><p>最后，安利一款 chrome 主题：<a href="https://chrome.google.com/webstore/detail/slinky-brushed/piiokbhpgldooopjdacdondngonfljoc?hl=zh-CN" target="_blank" rel="noopener"> Slinky </a>，换来换去最喜欢的还是这个！</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;1Password&lt;br&gt; 很久以前 iOS 限免的时候收的，配合起来用超级方便。最好用的密码管理软件（没有之一）。妈妈再也不用担心我不记得密码啦～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adblock Plus&lt;br&gt; 大名鼎鼎的ABP！广告？那是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instapaper&lt;br&gt; Instapaper 的 chrome 插件，快速保存页面内容到 Instapaper。话说最近 Instapaper 高级版永久免费了好像。
    
    </summary>
    
    
      <category term="Chrome" scheme="https://hopsken.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>记第一次十公里跑</title>
    <link href="https://hopsken.com/2016/03/27/1000m-running/"/>
    <id>https://hopsken.com/2016/03/27/1000m-running/</id>
    <published>2016-03-26T16:00:00.000Z</published>
    <updated>2016-10-04T10:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。<br>    <a id="more"></a><br>　　我是从新年过后才开始跑步的，到现在为止差不多一个多月了。差不多每周跑四次，每次至少五公里。截止目前，累计距离72.44公里，跑步记录14次。所以，我目前最多只能算是一个初级跑者。现在的目标是半年内完成一次半程马拉松，大学四年内至少完成三次全程马拉松。说起我跑步的原因，首先是为了减肥（我想这也是多数跑者开始跑步的原因吧）再者，是因为读了村上春树的《当我谈跑步时我谈些什么》，颇受触动，为其精神所感染。后来，不知从第几次跑步开始，我开始喜欢上了这项运动。我喜欢上了两公里时候脚酸的要死的感觉，喜欢上了四公里时腿重得像灌了铅的感觉，喜欢上了耳机里“您已经跑了五公里”的提示音，喜欢了五公里后多跑的每一百米。总之，不管愿不愿意，我已经爱上了跑步。</p><h3 id="10KM准备"><a href="#10KM准备" class="headerlink" title="10KM准备　"></a>10KM准备　</h3><p>　　在跑过十次五公里之后，我决定挑战一下10KM跑。时间是周日上午，地点是学校网球场旁的跑道。<br>　　<br>　　在经过了两天的休整之后，周日如期而至。九点起床，舍友还在酣睡之中；洗漱，特地把脸洗了两遍；吃早饭，还是以前吃的那些；顺道去食堂旁的小商店买了一瓶矿泉水以及一袋彩虹糖。认真地翻看网上找到的跑前拉伸动作。毕竟是第一次跑十公里，不能像以前跑五公里的时候那样只在跑完后做一下简单拉伸，不能太随意。<br>　　<br>　　终于来到了操场。因为是周日，操场没什么人。只有几个家长在带着孩子打网球，还有路过的去操场旁边的成人教育楼上课的人们。在做了十分钟的准备活动之后，就正式开始了我的十公里征程啦！<br>　　<br>　　因为不是标准化田径场，绕操场一圈的距离没具体测过，大概是300米吧。那么10KM就是要绕着跑三四十圈了。额，听起来有点吓人啊。不过，反正咱是慢跑，而且既然之前跑五公里跑完之后也不是很累，所以应该没什么问题吧。只要能保持6‘30’‘的配速，应该没什么问题的。</p><h3 id="以下内容纯属意识流"><a href="#以下内容纯属意识流" class="headerlink" title="以下内容纯属意识流"></a>以下内容纯属意识流</h3><p>　　“您已经跑了一公里，用时6’14‘’，剩余距离9公里”<br>　　“啊，已经跑了一公里了啊。今天有点冷啊。。再多跑几步应该就会暖和起来了吧。”<br>　　<br>　　“您已经跑了两公里，用时6‘38‘’，剩余距离8公里”<br>　　“已经跑了五分之一了啊！加油加油！哎，那边那个打网球的技术好烂啊。”<br>　　<br>　　“您已经跑了三公里，用时6‘28‘’，剩余距离7公里”<br>　　“哎呀，已经三公里了哎，差不多三分之一。奇怪，按理说这个时候腿已经开始酸了，今天怎么没有，难道是因为今天跑之前做足了拉伸。也许吧。看来今天状态不错嘛，跑个十公里应该没问题。哈哈哈”<br>　　<br>　　“您已经跑了四公里，用时6‘28’‘，剩余距离6公里”<br>　　“哟嚯，又是6’28‘’，记得上一公里也是花了这么长时间，看来速度控制的不错嘛。嗯，腿和脚都没有酸痛的感觉，nice！啊呀，这里有一坨‘犬之翔’哎。woc，还好没踩到。还好我机智，哈哈哈。”<br>　　<br>　　“您已经跑了五公里，用时6‘30’‘，剩余距离5公里”<br>　　“已经跑了五公里了啊，一半了哎，平时这个时候都可以停下来了。 嗯，目前看来，耐力和体力都没什么问题。加油吧！噫，这坨翔怎么还在这里。”<br>　　<br>　　“您已经跑了六公里，用时6’42‘’，剩余距离4公里”<br>　　“六公里了哈。woc，竟然有个妹子在男生宿舍门口，手里还拎了个星巴克的咖啡。好烦，可恶的情侣= =算了，我还是跑自己的步，懒得理你们。Hello，翔，你还在啊。”<br>　　<br>　　“您已经跑了七公里，用时6‘24’‘，剩余距离3公里”<br>　　“哎呀，我去，怎么还有三公里……一不小心就跑了45分钟了，我实在是太棒了！哈哈哈！呦，又有家长带着小孩来玩。哟嚯，不错啊，大叔，这么大啤酒肚玩的了单杠，给你竖个大拇指。额，还是不竖了吧，人家会觉得我是傻X吧。。”<br>　　<br>　　“您已经跑了八公里，用时6’34‘’，剩余距离2公里”<br>　　“八公里，还有两公里，哎呀，好烦啊，怎么还有两公里，妈呀，我不想跑了啊，老这么跑好无聊啊。前面那个跑超过我的那个女生，真是太不上路子了，哥这是在跑十公里好吗？十公里ok？我跑了这么久，你才跑一会儿，你怎么好意思跑超过我呢？你这样让我很难堪好吗？那啥，前面的那两个熊孩子让一让，挡住我的路了。算了，还是我让过去吧。。。woc，怎么这坨翔还在这里。”<br>　　<br>　　“您已经跑了九公里，用时6‘36’‘，剩余距离1公里，加油！”<br>　　“还有最后一公里啊，坚持下来都可以了！哎呀，一不小心就跑了将近一个小时了啊。哥实在是太厉害了！等会回去一定要把这次跑步写下来！嗯，等马上跑完，我要好好秀一秀😏”<br>　　<br>　　“您已经跑了十公里，用时6’40‘’。您已经完成十公里训练，休息一下吧！”<br>　　”啦啦啦！跑完啦~跑完了~腰也不酸，腿也不疼，脚也不痛。照这个节奏，跑个半马也没什么问题嘛。哥实在是太牛掰了！啊呀呀，做个胜利的手势吧！woc，手甩都了，举不起来。。。等会儿，刚才那坨翔哪去了Σ( ° △ °|||)“　　</p><h3 id="一些没什么用的建议"><a href="#一些没什么用的建议" class="headerlink" title="一些没什么用的建议"></a>一些没什么用的建议</h3><ul><li><p>如果你想去跑步的话，装一个跑步记录的APP吧。推荐”悦跑圈“<del>约炮圈?</del>。运动记录，跑鞋里程记录，跑团，线上马拉松等等，个人觉得还是不错的。<del>那啥，我就不要广告费，反正没多少人看我的博客</del></p></li><li><p>如果你想去跑步的话，买一双自己能力范围内最好的专业跑鞋吧。不仅可以一定程度上提高成绩，还能够让你舍不得放弃这项运动，毕竟割肉买的。。<del>不说了，我去找点土来准备晚饭了</del></p></li><li><p>如果你想去跑步的话，不要跑跑停停，只要还能跑就跑下去。还有一点就是，一开始速度不要太快，毕竟相比于一开始跑得快后来被别人一一超过，还是一开始慢一点然后一个一个超过别人比较爽。</p></li><li><p><b><em>以上，纯属个人看法。</em></b>　　</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　说来惭愧，当我写下这个题目的时候我已经快一个星期没有跑步了ಠ_ಠ 。之所以会写下这篇短文，一是和大家分享一下我跑步的经历；其次呢，是想要借此机会顺利度过所谓的“厌跑期”。&lt;br&gt;
    
    </summary>
    
    
      <category term="跑步" scheme="https://hopsken.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
</feed>
