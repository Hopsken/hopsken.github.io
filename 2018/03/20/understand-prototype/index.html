<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>理解 JavaScript 继承与原型链 · Hopsken</title><meta name="description" content="理解 JavaScript 继承与原型链 - Hopsken"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/wen.css"><link rel="search" type="application/opensearchdescription+xml" href="https://hopsken.com/atom.xml" title="Hopsken"></head><body><header class="header"><div class="logo"><a href="/" class="logo-tm"><img src="/assets/hopsken.jpg" alt="logo"><div><h3> Hopsken</h3><h4> Blogger</h4></div></a></div><nav role="navigation" class="nav"><ul class="nav-list"><li class="nav-item"><a href="/" target="_self">HOME</a></li><li class="nav-item"><a href="/archives" target="_self">ARCHIVES</a></li><li class="nav-item"><a href="https://github.com/hopsken" target="_blank">GITHUB</a></li><li class="nav-item"><a href="/atom.xml" target="_self">RSS</a></li></ul></nav></header><main role="main" class="main"><section class="main-content clearfix"><section class="content"><div class="title"><h1>理解 JavaScript 继承与原型链</h1><div class="title-meta"><span>Mar 20, 2018</span><span>•</span><span>Tagged in <a href="/tags/JavaScript/" title="JavaScript">JavaScript </a></span></div></div></section><article class="article"><p>相信很多小伙伴在刚开始接触 JavaScript 的继承机制时都会感到一头雾水，特别是对于有面向对象编程语言（如Java，Python等）经验的同学。因为 JavaScript 本身不提供 class 实现，而是使用一种称作『原型链』的方法来模拟了类的继承。<br><a id="more"></a></p>
<p>要想理解原型链，首先需要知道的一点就是 JavaScript 是基于对象的。每一个对象都有一个私有属性<code>[[prototype]]</code>，它指向它的原型对象（prototype）。该原型对象又有一个自己的 prototype，层层向上直到一个对象的原型为<code>null</code>。这就是原型链，原型链的作用就是把这些对象联系起来。</p>
<h2 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h2><p>构造函数本质上就是函数声明，与普通函数不同的是，我们人为地使用首字母大写来将其与普通函数区分开。因为 JavaScript 中，函数本质上也是对象，所以构造函数具有 <code>prototype</code> 属性。我们可以利用这一点模拟出类的继承。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>为了更好的理解，我们来举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//定义一个 Cat 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将 Cat 原型指向一个对象</span></div><div class="line"><span class="comment">//该对象定义了一个 meow 方法</span></div><div class="line">Cat.prototype = &#123;</div><div class="line">    <span class="attr">meow</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"meow meow meow~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过 new 关键字创建两个 Cat 实例</span></div><div class="line"><span class="keyword">let</span> kitty = <span class="keyword">new</span> Cat(<span class="string">"Kitty"</span>);</div><div class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>);</div><div class="line"></div><div class="line">kitty.name          <span class="comment">//=&gt;"Kitty"</span></div><div class="line">tom.name            <span class="comment">//=&gt;"Tom"</span></div><div class="line">kitty.meow()        <span class="comment">//=&gt;"meow meow meow~~"</span></div><div class="line">tom.meow()          <span class="comment">//=&gt;"meow meow meow~~"</span></div></pre></td></tr></table></figure>
<p>当我们调用实例对象的属性和方法时，JavaScript 会先尝试在当前对象自有的属性和方法中查找，如果没有，则会去该对象的原型，即 <code>prototype</code> 指向的对象中查找，并以此类推。如果直到原型链的终端 <code>null</code> 都没有，则返回 <code>undefined</code>。因此当调用 <code>meow</code> 方法时，因为构造函数中没有定义此方法，所以 JavaScript 会去对象的原型中查找 <code>meow</code> 方法。这样就实现了在各个实例间共享方法。</p>
<p>注意：当我们调用继承的属性时，<code>this</code> 始终指向当前继承的对象，而不是继承的函数所在的原型对象。因此当我们调用 <code>name</code> 属性时，会返回对应的属性值。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>每一个 JavaScript 对象（<code>null</code>除外）都会有一个 <code>__proto__</code> 属性。如果说 <code>prototype</code> 属性表达了构造函数和实例原型之间的关系，那么 <code>__proto__</code> 表明了实例与实例原型之间的关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">kitty.__proto__ === Cat.prototype   <span class="comment">//=&gt;true</span></div><div class="line"></div><div class="line"><span class="comment">//ES5中定义的另一个获取对象原型的方法</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(kitty) === Cat.prototype  <span class="comment">//=&gt;true</span></div></pre></td></tr></table></figure>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>对象还有另外一个属性 <code>constructor</code> 。与 <code>prototype</code> 相反，<code>constructor</code> 是原型的属性，指向该原型的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Cat.prototype.constructor === Cat   <span class="comment">//=&gt;true</span></div></pre></td></tr></table></figure>
<p>详细关系图如下，摘自<a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">Github: mqyqingfeng/Blog</a><br><img src="https://o8r4eescd.qnssl.com/15217112091355.png" alt=""></p>
<h3 id="new-的时候发生了什么？"><a href="#new-的时候发生了什么？" class="headerlink" title="new 的时候发生了什么？"></a>new 的时候发生了什么？</h3><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN </a>上的解释：当代码 new Foo(…) 执行时，会发生以下事情：</p>
<ol>
<li>一个继承自 Foo.prototype 的新对象被创建。</li>
<li>使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li>
<li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>
</ol>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car(<span class="string">"Porsche"</span>)</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> car = (<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> ret = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</div><div class="line">        ret.__proto__ = func.prototype</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> ret1 = func.apply(ret, [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ret1 === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret1 === <span class="string">"function"</span> &amp;&amp; ret1 !== <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ret1;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;)(Car, <span class="string">"Porsche"</span>)</div></pre></td></tr></table></figure>
<h2 id="使用Object-create-方法"><a href="#使用Object-create-方法" class="headerlink" title="使用Object.create()方法"></a>使用Object.create()方法</h2><p>ES5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div></pre></td></tr></table></figure>
<h2 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 class 关键字</h2><p>ES6 中引入了一套新的关键字用来实现 <code>class</code>，但它仍然是基于原型的。详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类 - MDN</a>。</p>
<p><em>参考资料：</em></p>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链 - MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create() - MDN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想 - 阮一峰的网络日志</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">mqyqingfeng/Blog - Github</a></li>
<li><a href="https://blog.oyanglul.us/javascript/understand-prototype.html" target="_blank" rel="noopener">理解JavaScript的原型链和继承 - blog.oyanglul.us</a></li>
</ol>
</article></section><div class="pagination"><ul><li class="pagination-item"><a href="/2018/03/18/CSS-units/" class="next">Next</a></li></ul></div><div class="comment"></div><footer class="footer">© 2018 Made with ❤️ by Hopsken.</footer></main></body></html>